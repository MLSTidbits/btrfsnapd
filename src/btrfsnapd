#!/usr/bin/env bash

# Copyright (c) 2024 Michael Schaecher <MichaelLeeSchaecher@gmail.com>
# Copyright (c) 2025 MLS Tidbits <contact@mlstidbits.com>

# btrfsnapd - A BTRFS snapshot management script

# shellcheck disable=SC2329
function sign-handler () {

    local signalHandler="${1:-SIGINT}"

    case "$signalHandler" in
        SIGINT|SIGTERM|SIGQUIT )
            event-log "info" "Received $signalHandler, cleaning up and exiting"         ;;
        EXIT                   ) event-log "info" "Exiting script"             ; exit 0 ;;
        *                      ) event-log "warning" "Unhandled signal: $signalHandler" ;;
    esac

    clean-up

}

# Log all output to event-log
function event-log () {

    local eventType="${1:-info}"
    local eventMessage="${2}"

    case "${eventType}" in
        info|warning|error )
            logger -t btrfsnapd -p user."${eventType}" "${eventMessage}"
            [[ "${eventType}" == "error" ]] && exit 1
        ;;
        *                  ) logger -t btrfsnapd -p user.info "${eventMessage}" ;;
    esac

}

function clean-up () {

    local mountedTmpDirs

    mount | awk '$3 ~ /^\/tmp\// { print $3 }' | while read -r mountedTmpDirs ; do

        if mountpoint -q "$mountedTmpDirs" ; then
            umount "$mountedTmpDirs" || event-log "error" "Unmount failed for $mountedTmpDirs"
        fi

        rm -Rf "$mountedTmpDirs" || event-log "error" "Removal failed for $mountedTmpDirs"

    done

    event-log "info" "Cleaning up temporary directories"
}

function check-root () { (( $(id -u) == 0 )) || event-log "error" "This script must be run as root" ; }

function take-snapshot () {

    # Check if the script is run with root privileges
    check-root

    local confirmSnapshot="no"

    local snapshotOptions=""

    local targetDir="$snapshotsDir"
    local sourceDir="/"

    shift

     [[ "$1" == "-h" || "$1" == "--help" ]] && { echo "$_createHelpInfo" ; exit 0 ; }

    if ! test -d "$snapshotsDir" ; then
        event-log "warning" "Snapshot subvolume $snapshotsDir does not exist, creating it"
        # Check if there is a subvolume for snapshots or snapshot, if not create it
        if ! btrfs subvolume list / | grep -q "@snapshots" ; then
            btrfs subvolume create "$snapshotsDir" || {
            event-log "error" "Failed to create snapshot subvolume $snapshotsDir" ; exit 1 ; }
        fi
        event-log "info" "Created snapshot subvolume $snapshotsDir"
    fi

    while [[ $# -gt 0 ]] ; do case "${1}" in
        -r|--read-only ) snapshotOptions="$snapshotOptions -r "     ; shift  ;;
        -y|--yes       ) confirmSnapshot="yes"                      ; shift  ;;
        -s|--source    )

            # Set the source directory from which to create the snapshot.
            case "${2}" in
                root   ) sourceDir="/"                                       ;;
                home   ) sourceDir="/home"                                   ;;
                logs   ) sourceDir="/log"                                    ;;
                *      ) event-log "Invalid source directory: ${2}" ; exit 1 ;;
            esac
            shift 2

        ;;
        -t|--target    )

            # Check if a flag is next instead of a directory
            [[ "$2" == -* ]] && targetDir="$snapshotsDir" || targetDir="/${2}"
            shift 2

        ;;
        -w|--writeable )

            # Verify that the target directory exists
            test -d "${2}" || event-log "error" "Snapshot directory ${2} does not exist"

            if  btrfs property set "${2}" ro false ; then
                event-log "error" "Failed with setting snapshot ${2} to writeable"
            else
                event-log "info" "Snapshot ${2} set to writeable"
            fi

            exit 0
        ;;
        *) break ;;
    esac ; done

    # Verify that the target directory exists
    test -d "$targetDir" || event-log "error" "$targetDir does not exist."

    # shellcheck disable=SC2155
    local snapshotOut="$targetDir/${_distroName}_${_snapshotType}_$(date +%Y%m%d+%H%M)"
    local verifySnapshot=""

    if test "$confirmSnapshot" != "yes" ; then

        # Prompt the user for confirmation before creating the snapshot.
        read -rp "Create snapshot ${sourceDir} -> ${snapshotOut}? [y/N] " choice

        if [[ "$choice" =~ ^[yY](es)?$ ]] ; then
            event-log "info" "Snapshot creation cancelled by user"
            exit 0
        fi

    fi

    # shellcheck disable=SC2086
    btrfs su snapshot ${snapshotOptions} ${sourceDir} ${snapshotOut} ||
    event-log "error" "Createion of snapshot ${snapshotOut} failed"

    event-log "info" "Snapshot of ${sourceDir} created in $targetDir"

    clean-up

}

function run_cycle_delete () {

    event-log "info" "Automatically deleting oldest snapshots in $targetDir"

    while true ; do

        _oldSnapshots="$(btrfs su list -o --sort=ogen "$targetDir" | awk -F'/' 'NR==1 {print $2}')"

        # Using the find command is better then ls, however the one less snapshot is kept.
        # Need to add 1 to the TOTAL_KEEP variable to keep the correct number of snapshots.
        count=$((_totalCount + 1))

        _snapshotList="$(find "$targetDir" -maxdepth 1 -type d | wc -l)"

        if test "${_snapshotList}" -gt "${count}" ; then
            btrfs su delete "$targetDir/${_oldSnapshots}" ||
            { event-log "error" "Failed deleting snapshot $targetDir/${_oldSnapshots}" ; exit 1 ; }
        else
            event-log "info" "No snapshots to delete, keeping ${_totalCount} snapshots in $targetDir"
            break
        fi

    done

}

function delete_snapshot () {

    local _snapshotsList _snapshotsName _oldSnapshots _snapshotList

    _snapshotsList=()
    targetDir="$snapshotsDir"
    _oldest="no"
    confirmSnapshot="no"

    shift

    [[ "$1" == "-h" || "$1" == "--help" ]] && { echo "${_deleteHelpInfo}" ; exit 0 ; }

    # Check if the script is run with root privileges
    check-root

    # shellcheck disable=SC2222
    # shellcheck disable=SC2221
    while [ $# -gt 0 ] ; do case "$1" in
        -o|--oldest             ) _oldest="yes"                  ; shift ;;
        -y|--yes                ) confirmSnapshot="yes"                 ; shift ;;
        -p|--purge              )
            [ -n "$2" ] || test -d "$targetDir/${2}" ||
            { event-log "error" "Purge snapshot directory/name is not valid: ${2}" ; exit 1 ; }
            _purgeSnapshot="$targetDir/${2}"
            shift 2
        ;;
        -l|--list               )
            while IFS= read -r -d $'\0' snap; do
                _snapshotsName=$(basename "$snap")
                _snapshotsList+=("$_snapshotsName")
            done < <(find "$targetDir" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)

            echo "Please select a snapshot to delete: (ctrl+c to cancel)"
            echo ""
            select snap in "${_snapshotsList[@]}"; do
                if [ -n "$snap" ]; then
                    _selectedSnapshot="$snap"
                    break
                else
                    echo "Invalid selection. Try again."
                fi
            done
            shift
            ;;
        -*|--*                  ) echo "Invalid option: $1" >&2 ; exit 1 ;;
        *                       ) shift                                  ;;
    esac ; done


    if [ -n "$_selectedSnapshot" ] && [ "$confirmSnapshot" = "no" ] ; then
        read -rp "Delete snapshot $_selectedSnapshot in $targetDir? [y/N] " choice
        _oldSnapshots="$_selectedSnapshot"
        case "${choice}" in
            [yY][eE][sS]|[yY]) btrfs su delete "$targetDir/${_oldSnapshots}"        ;;
            [nN][oO]|[nN]    ) echo "Snapshot deletion cancelled"             ; exit 0 ;;
            *                ) echo "Invalid choice, please enter 'y' or 'n'" ; exit 1 ;;
        esac
    elif [ -n "$_selectedSnapshot" ] && [ "$confirmSnapshot" = "yes" ] ; then
        btrfs su delete "$targetDir/${_selectedSnapshot}" || {
        event-log "error" "Failed to delete snapshot ${_selectedSnapshot} in $targetDir" ; exit 1 ; }
    fi

    # Delete snapshots exceeding the total to keep
    if [ "$_oldest" = "yes" ] && [ "$confirmSnapshot" = "yes" ] ; then
        run_cycle_delete
    elif [ "$_oldest" = "yes" ] && [ "$confirmSnapshot" = "no" ] ; then
        read -rp "Delete the oldest snapshot in $targetDir? [y/N] " choice
        case "${choice}" in
            [yY][eE][sS]|[yY]) run_cycle_delete ;;
            [nN][oO]|[nN]    ) echo "Oldest snapshot deletion cancelled" ; exit 0 ;;
            *                ) echo "Invalid choice, please enter 'y' or 'n'" ; exit 1 ;;
        esac
    fi

    if [ -n "$_purgeSnapshot" ] && [ "$confirmSnapshot" = "yes" ] ; then
        btrfs su delete "${_purgeSnapshot}" || {
        event-log "error" "Failed to delete snapshot ${_purgeSnapshot}" ; exit 1 ; }
    elif [ -n "$_purgeSnapshot" ] && [ "$confirmSnapshot" = "no" ] ; then
        read -rp "Purge snapshot $_purgeSnapshot? [y/N] " choice
        case "${choice}" in
            [yY][eE][sS]|[yY]) btrfs su delete "${_purgeSnapshot}"                     ;;
            [nN][oO]|[nN]    ) echo "Snapshot purge cancelled"                ; exit 0 ;;
            *                ) echo "Invalid choice, please enter 'y' or 'n'" ; exit 1 ;;
        esac
    fi

    clean-up

}

function restore_snapshot () {

    shift

    local _fsPath _snapshotsList targetDir sourceDir
    local _selectedSnapshot _snapshotsName confirmSnapshot

    confirmSnapshot="no"

    [[ "$1" == "-h" || "$1" == "--help" ]] && { echo "${_restoreHelpInfo}" ; exit 0 ; }

    # Check if the script is run with root privileges
    check-root

    mountedTmpDirs="$(mktemp -d)"

    # Get the dev path of the btrfs filesystem
    _fsPath="$(lsblk -o fstype,path | awk '$1 == "btrfs" {print $2}')"

    mount "$_fsPath" "$mountedTmpDirs" || { event-log "error" "Failed to mount btrfs filesystem $_fsPath" ; exit 1 ; }

    snapshotsDir="$mountedTmpDirs/@snapshots"
    sourceDir="$mountedTmpDirs/@"

    # shellcheck disable=SC2222
    # shellcheck disable=SC2221
    while [ $# -gt 0 ] ; do case "$1" in
        -l|--list               )
            _snapshotsList=()
            targetDir="$snapshotsDir"
            while IFS= read -r -d $'\0' snap; do
                _snapshotsName=$(basename "$snap") && _snapshotsList+=("$_snapshotsName")
            done < <(find "$targetDir" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)

            if [ ${#_snapshotsList[@]} -eq 0 ]; then
                event-log "error" "No snapshots found in $targetDir" ; exit 1
            fi

            echo "Please select a snapshot to restore from: (ctrl+c to cancel)"
            echo ""

            select snap in "${_snapshotsList[@]}"; do
                if [ -n "$snap" ]; then
                    _selectedSnapshot="$snap"
                    break
                else
                    echo "Invalid selection. Try again."
                fi
            done
            shift
            ;;
        -y|--yes                )
            confirmSnapshot="yes"
            shift
            ;;
        -s|--source             )
            if [ -z "$2" ]; then
                echo "Error: --source requires a value (root, home, logs)." >&2
                exit 1
            fi
            case "$2" in
                root) sourceDir="$mountedTmpDirs/@" ;;
                home) sourceDir="$mountedTmpDirs/@home" ;;
                logs) sourceDir="$mountedTmpDirs/@log" ;;
                *) echo "Invalid source directory: $2" ; exit 1 ;;
            esac
            shift 2
            ;;
        -*|--*                  )
            echo "Invalid option: $1" >&2
            exit 1
            ;;
        *                       ) shift ;;
        esac ; done

    if [ "$confirmSnapshot" != "yes" ]; then
        read -rp "Are you sure you want to restore ${sourceDir} from $_selectedSnapshot? [y/N] " _choice
        case "$_choice" in
            [yY][eE][sS]|[yY]) ;;
            [nN][oO]|[nN]) echo "Snapshot restoration cancelled" ; exit 0 ;;
            *) echo "Invalid choice, please enter 'y' or 'n'" ; exit 1 ;;
        esac
    fi

    if btrfs su delete "${sourceDir}" && \
       btrfs su snapshot "$snapshotsDir/$_selectedSnapshot" "${sourceDir}"; then
        event-log "info" "Snapshot $_selectedSnapshot restored to ${sourceDir}"
    else
        event-log "error" "Failed to restore snapshot $_selectedSnapshot to ${sourceDir}" ; exit 1
    fi

    umount "$mountedTmpDirs" || {
        event-log "error" "Failed to unmount temporary directory $mountedTmpDirs" ; exit 1 ;
    }

    clean-up
}

function list_snapshots () {

    check-root

    local _listSnapshotsDir

    _listSnapshotsDir="$snapshotsDir"

        # List all snapshots in the snapshot directory
    if test -d "$_listSnapshotsDir" ; then
        echo "$_versionInfo"
        echo ""
        echo "Name              Source           Date"
        echo "---------------------------------------------------"
        echo ""

        find "$_listSnapshotsDir" -mindepth 1 -maxdepth 1 -type d | sort | while read -r snap ; do
            _name="$(basename "$snap" | awk -F'_' '{print $1}')"
            _source="$(basename "$snap" | awk -F'_' '{print $2}')"
            _date="$(basename "$snap" | awk -F'_' '{print $3}' | sed 's/+/ /g')"
            echo "$_name           $_source             $_date"
        done
    else
        echo "No snapshots found in $snapshotsDir"
    fi
}

set -eo pipefail

# shellcheck disable=SC1091
source /etc/btrfsnapd.conf 2> /dev/null || {
    echo "Failed to source configuration file /etc/btrfsnapd.conf" >&2
    exit 1
}

# shellcheck disable=SC1091
test ! -f /etc/os-release || source /etc/os-release

_appName="btrfsnapd"
_appVersion="$(cat /usr/share/doc/btrfsnapd/version 2> /dev/null || echo "unknown")"

# Default values for general snapshot for the root filesystem
_distroName="${DISTRO_NAME:-$NAME}"
# deal with the case where NAME has spaces
if echo "$_distroName" | grep -q ' ' ; then
    _distroName="$(echo "$_distroName" | tr -d '[:space:]')"
fi

_snapshotType="${SNAPSHOT_TYPE:-root}"

snapshotsDir="${SNAPSHOT_DIR:-/.snapshots}"
_setDate="${SET_DATE:-true}"
_readOnly="${READ_ONLY:-false}"

# How many snapshots to keep. This should be keep low to avoid using too much disk space.
_totalCount="${TOTAL_COUNT:-7}"

# Trap errors and log them
trap sign-handler SIGINT SIGTERM SIGQUIT EXIT

_licenseInfo="$(cat << EOF
$_appName - Copyright (c) 2024 by Michael L. Schaecher <MichaelLeeSchaecher@gmail.com> under the terms
of the GPLv3 License or later.
EOF
)"

_versionInfo="$(cat << EOF
${_appName} [ version ${_appVersion} ] - $_distroName ${VERSION}
EOF
)"

_helpInfo="$(cat << EOF
$_versionInfo

Usage: ${_appName} [options] <flags> arg...

Options:
    create                      Create a new snapshot based on configured settings.
    delete                      Delete a snapshot based on configured settings
    restore                     Restore a subvolume to a previous state
    list                        List all snapshots in the snapshot directory.
    help                        Show this help message.
    version                     Show version information.

Flags:
    -h, --help                  Show help information for options: (\`create\`, \`delete\`, \`restore\`)

${_licenseInfo}
EOF
)"

_createHelpInfo="$(cat << EOF
$_versionInfo

Usage: ${_appName} create <flags> arg...

Options:
    create                      Create a new snapshot based on configured settings.

Flag:
    -r, --read-only             Create a read-only snapshot: This will not allow any changes to the snapshot
                                after creation.
    -y, --yes                   Skip the confirmSnapshotation prompt before creating the snapshot.
    -s, --source <source>       Specify the source for the snapshot: [\`root\`, \`home\`, or \`logs\`].
    -t, --target <target>       Specify the target location for the snapshot: [Default is \`/.snapshots\`].
    -w, --writeable             Convert a given snapshot to a writeable state: This allows changes to be made
                                to the snapshot after creation.
    -h, --help                  Show help information for creating a snapshot.

${_licenseInfo}
EOF
)"

_deleteHelpInfo="$(cat << EOF
$_versionInfo

Usage: ${_appName} delete <flags> arg...

Options:
    delete                     Delete a snapshot based on configured settings.

Flags:
    -o, --oldest               Delete the oldest snapshot in the snapshot directory.
    -l, --list                 List all available snapshots in the snapshot directory.
    -y, --yes                  Skip the confirmSnapshotation prompt before deleting the snapshot.
    -h, --help                 Show help information for deleting a snapshot.

${_licenseInfo}
EOF
)"

_restoreHelpInfo="$(cat << EOF
$_versionInfo

Usage: ${_appName} restore <flags> arg...

Options:
    restore                   Restore a subvolume to a previous state.

Flags:
    -l, --list                List all available snapshots in the snapshot directory.
    -y, --yes                 Skip the confirmSnapshotation prompt before restoring the snapshot.
    -s, --source <source>     Specify the source to be restored: [\`root\`, \`home\`, or \`logs\`].
    -h, --help                Show help information for restoring a snapshot.

${_licenseInfo}
EOF
)"

trap "clean-up" SIGINT

case "${1}" in
    create              ) take-snapshot "${@}"                   ;;
    delete              ) delete_snapshot "${@}"                 ;;
    restore             ) restore_snapshot "${@}"                ;;
    cleanup             ) clean-up                               ;;
    list                ) list_snapshots                         ;;
    help                ) echo "${_helpInfo}"           ; exit 0 ;;
    version             ) echo "$_versionInfo"          ; exit 0 ;;
    *                   ) echo "Invalid argument: ${1}" ; exit 1 ;;
esac

exit 0
